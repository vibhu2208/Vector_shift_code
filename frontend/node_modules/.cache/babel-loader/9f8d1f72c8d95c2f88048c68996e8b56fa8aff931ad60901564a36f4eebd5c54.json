{"ast":null,"code":"// src/index.ts\nimport equal2 from \"@gilbarbara/deep-equal\";\nimport is2 from \"is-lite\";\n\n// src/helpers.ts\nimport equal from \"@gilbarbara/deep-equal\";\nimport is from \"is-lite\";\nfunction canHaveLength(...arguments_) {\n  return arguments_.every(d => is.string(d) || is.array(d) || is.plainObject(d));\n}\nfunction checkEquality(left, right, value) {\n  if (!isSameType(left, right)) {\n    return false;\n  }\n  if ([left, right].every(is.array)) {\n    return !left.some(hasValue(value)) && right.some(hasValue(value));\n  }\n  if ([left, right].every(is.plainObject)) {\n    return !Object.entries(left).some(hasEntry(value)) && Object.entries(right).some(hasEntry(value));\n  }\n  return right === value;\n}\nfunction compareNumbers(previousData, data, options) {\n  const {\n    actual,\n    key,\n    previous,\n    type\n  } = options;\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n  let changed = [left, right].every(is.number) && (type === \"increased\" ? left < right : left > right);\n  if (!is.undefined(actual)) {\n    changed = changed && right === actual;\n  }\n  if (!is.undefined(previous)) {\n    changed = changed && left === previous;\n  }\n  return changed;\n}\nfunction compareValues(previousData, data, options) {\n  const {\n    key,\n    type,\n    value\n  } = options;\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n  const primary = type === \"added\" ? left : right;\n  const secondary = type === \"added\" ? right : left;\n  if (!is.nullOrUndefined(value)) {\n    if (is.defined(primary)) {\n      if (is.array(primary) || is.plainObject(primary)) {\n        return checkEquality(primary, secondary, value);\n      }\n    } else {\n      return equal(secondary, value);\n    }\n    return false;\n  }\n  if ([left, right].every(is.array)) {\n    return !secondary.every(isEqualPredicate(primary));\n  }\n  if ([left, right].every(is.plainObject)) {\n    return hasExtraKeys(Object.keys(primary), Object.keys(secondary));\n  }\n  return ![left, right].every(d => is.primitive(d) && is.defined(d)) && (type === \"added\" ? !is.defined(left) && is.defined(right) : is.defined(left) && !is.defined(right));\n}\nfunction getIterables(previousData, data, {\n  key\n} = {}) {\n  let left = nested(previousData, key);\n  let right = nested(data, key);\n  if (!isSameType(left, right)) {\n    throw new TypeError(\"Inputs have different types\");\n  }\n  if (!canHaveLength(left, right)) {\n    throw new TypeError(\"Inputs don't have length\");\n  }\n  if ([left, right].every(is.plainObject)) {\n    left = Object.keys(left);\n    right = Object.keys(right);\n  }\n  return [left, right];\n}\nfunction hasEntry(input) {\n  return ([key, value]) => {\n    if (is.array(input)) {\n      return equal(input, value) || input.some(d => equal(d, value) || is.array(value) && isEqualPredicate(value)(d));\n    }\n    if (is.plainObject(input) && input[key]) {\n      return !!input[key] && equal(input[key], value);\n    }\n    return equal(input, value);\n  };\n}\nfunction hasExtraKeys(left, right) {\n  return right.some(d => !left.includes(d));\n}\nfunction hasValue(input) {\n  return value => {\n    if (is.array(input)) {\n      return input.some(d => equal(d, value) || is.array(value) && isEqualPredicate(value)(d));\n    }\n    return equal(input, value);\n  };\n}\nfunction includesOrEqualsTo(previousValue, value) {\n  return is.array(previousValue) ? previousValue.some(d => equal(d, value)) : equal(previousValue, value);\n}\nfunction isEqualPredicate(data) {\n  return value => data.some(d => equal(d, value));\n}\nfunction isSameType(...arguments_) {\n  return arguments_.every(is.array) || arguments_.every(is.number) || arguments_.every(is.plainObject) || arguments_.every(is.string);\n}\nfunction nested(data, property) {\n  if (is.plainObject(data) || is.array(data)) {\n    if (is.string(property)) {\n      const props = property.split(\".\");\n      return props.reduce((acc, d) => acc && acc[d], data);\n    }\n    if (is.number(property)) {\n      return data[property];\n    }\n    return data;\n  }\n  return data;\n}\n\n// src/index.ts\nfunction treeChanges(previousData, data) {\n  if ([previousData, data].some(is2.nullOrUndefined)) {\n    throw new Error(\"Missing required parameters\");\n  }\n  if (![previousData, data].every(d => is2.plainObject(d) || is2.array(d))) {\n    throw new Error(\"Expected plain objects or array\");\n  }\n  const added = (key, value) => {\n    try {\n      return compareValues(previousData, data, {\n        key,\n        type: \"added\",\n        value\n      });\n    } catch {\n      return false;\n    }\n  };\n  const changed = (key, actual, previous) => {\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is2.defined(actual);\n      const hasPrevious = is2.defined(previous);\n      if (hasActual || hasPrevious) {\n        const leftComparator = hasPrevious ? includesOrEqualsTo(previous, left) : !includesOrEqualsTo(actual, left);\n        const rightComparator = includesOrEqualsTo(actual, right);\n        return leftComparator && rightComparator;\n      }\n      if ([left, right].every(is2.array) || [left, right].every(is2.plainObject)) {\n        return !equal2(left, right);\n      }\n      return left !== right;\n    } catch {\n      return false;\n    }\n  };\n  const changedFrom = (key, previous, actual) => {\n    if (!is2.defined(key)) {\n      return false;\n    }\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is2.defined(actual);\n      return includesOrEqualsTo(previous, left) && (hasActual ? includesOrEqualsTo(actual, right) : !hasActual);\n    } catch {\n      return false;\n    }\n  };\n  const decreased = (key, actual, previous) => {\n    if (!is2.defined(key)) {\n      return false;\n    }\n    try {\n      return compareNumbers(previousData, data, {\n        key,\n        actual,\n        previous,\n        type: \"decreased\"\n      });\n    } catch {\n      return false;\n    }\n  };\n  const emptied = key => {\n    try {\n      const [left, right] = getIterables(previousData, data, {\n        key\n      });\n      return !!left.length && !right.length;\n    } catch {\n      return false;\n    }\n  };\n  const filled = key => {\n    try {\n      const [left, right] = getIterables(previousData, data, {\n        key\n      });\n      return !left.length && !!right.length;\n    } catch {\n      return false;\n    }\n  };\n  const increased = (key, actual, previous) => {\n    if (!is2.defined(key)) {\n      return false;\n    }\n    try {\n      return compareNumbers(previousData, data, {\n        key,\n        actual,\n        previous,\n        type: \"increased\"\n      });\n    } catch {\n      return false;\n    }\n  };\n  const removed = (key, value) => {\n    try {\n      return compareValues(previousData, data, {\n        key,\n        type: \"removed\",\n        value\n      });\n    } catch {\n      return false;\n    }\n  };\n  return {\n    added,\n    changed,\n    changedFrom,\n    decreased,\n    emptied,\n    filled,\n    increased,\n    removed\n  };\n}\nexport { treeChanges as default };","map":{"version":3,"names":["equal2","is2","equal","is","canHaveLength","arguments_","every","d","string","array","plainObject","checkEquality","left","right","value","isSameType","some","hasValue","Object","entries","hasEntry","compareNumbers","previousData","data","options","actual","key","previous","type","nested","changed","number","undefined","compareValues","primary","secondary","nullOrUndefined","defined","isEqualPredicate","hasExtraKeys","keys","primitive","getIterables","TypeError","input","includes","includesOrEqualsTo","previousValue","property","props","split","reduce","acc","treeChanges","Error","added","hasActual","hasPrevious","leftComparator","rightComparator","changedFrom","decreased","emptied","length","filled","increased","removed"],"sources":["C:\\Users\\vaibh\\OneDrive\\Desktop\\Reseachpaper\\vector\\vector\\frontend\\node_modules\\tree-changes\\src\\index.ts","C:\\Users\\vaibh\\OneDrive\\Desktop\\Reseachpaper\\vector\\vector\\frontend\\node_modules\\tree-changes\\src\\helpers.ts"],"sourcesContent":["import equal from '@gilbarbara/deep-equal';\nimport is from 'is-lite';\n\nimport { compareNumbers, compareValues, getIterables, includesOrEqualsTo, nested } from './helpers';\nimport { Data, KeyType, TreeChanges, Value } from './types';\n\nexport default function treeChanges<P extends Data, D extends Data, K = KeyType<P, D>>(\n  previousData: P,\n  data: D,\n): TreeChanges<K> {\n  if ([previousData, data].some(is.nullOrUndefined)) {\n    throw new Error('Missing required parameters');\n  }\n\n  if (![previousData, data].every(d => is.plainObject(d) || is.array(d))) {\n    throw new Error('Expected plain objects or array');\n  }\n\n  const added = (key?: K, value?: Value): boolean => {\n    try {\n      return compareValues<K>(previousData, data, { key, type: 'added', value });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const changed = (key?: K | string, actual?: Value, previous?: Value): boolean => {\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is.defined(actual);\n      const hasPrevious = is.defined(previous);\n\n      if (hasActual || hasPrevious) {\n        const leftComparator = hasPrevious\n          ? includesOrEqualsTo(previous, left)\n          : !includesOrEqualsTo(actual, left);\n        const rightComparator = includesOrEqualsTo(actual, right);\n\n        return leftComparator && rightComparator;\n      }\n\n      if ([left, right].every(is.array) || [left, right].every(is.plainObject)) {\n        return !equal(left, right);\n      }\n\n      return left !== right;\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const changedFrom = (key: K | string, previous: Value, actual?: Value): boolean => {\n    if (!is.defined(key)) {\n      return false;\n    }\n\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is.defined(actual);\n\n      return (\n        includesOrEqualsTo(previous, left) &&\n        (hasActual ? includesOrEqualsTo(actual, right) : !hasActual)\n      );\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const decreased = (key: K, actual?: Value, previous?: Value): boolean => {\n    if (!is.defined(key)) {\n      return false;\n    }\n\n    try {\n      return compareNumbers<K>(previousData, data, { key, actual, previous, type: 'decreased' });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const emptied = (key?: K): boolean => {\n    try {\n      const [left, right] = getIterables(previousData, data, { key });\n\n      return !!left.length && !right.length;\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const filled = (key?: K): boolean => {\n    try {\n      const [left, right] = getIterables(previousData, data, { key });\n\n      return !left.length && !!right.length;\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const increased = (key: K, actual?: Value, previous?: Value): boolean => {\n    if (!is.defined(key)) {\n      return false;\n    }\n\n    try {\n      return compareNumbers<K>(previousData, data, { key, actual, previous, type: 'increased' });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const removed = (key?: K, value?: Value): boolean => {\n    try {\n      return compareValues<K>(previousData, data, { key, type: 'removed', value });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  return { added, changed, changedFrom, decreased, emptied, filled, increased, removed };\n}\n\nexport type { Data, KeyType, TreeChanges, Value } from './types';\n","import equal from '@gilbarbara/deep-equal';\nimport is from 'is-lite';\n\nimport { CompareValuesOptions, Data, Key, Options, ValidTypes, Value } from './types';\n\nexport function canHaveLength(...arguments_: any): boolean {\n  return arguments_.every((d: unknown) => is.string(d) || is.array(d) || is.plainObject(d));\n}\n\nexport function checkEquality(left: Data, right: Data, value: Value) {\n  if (!isSameType(left, right)) {\n    return false;\n  }\n\n  if ([left, right].every(is.array)) {\n    return !left.some(hasValue(value)) && right.some(hasValue(value));\n  }\n\n  /* istanbul ignore else */\n  if ([left, right].every(is.plainObject)) {\n    return (\n      !Object.entries(left).some(hasEntry(value)) && Object.entries(right).some(hasEntry(value))\n    );\n  }\n\n  return right === value;\n}\n\nexport function compareNumbers<K = Key>(\n  previousData: Data,\n  data: Data,\n  options: Options<K>,\n): boolean {\n  const { actual, key, previous, type } = options;\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n\n  let changed =\n    [left, right].every(is.number) && (type === 'increased' ? left < right : left > right);\n\n  if (!is.undefined(actual)) {\n    changed = changed && right === actual;\n  }\n\n  if (!is.undefined(previous)) {\n    changed = changed && left === previous;\n  }\n\n  return changed;\n}\n\nexport function compareValues<K = Key>(\n  previousData: Data,\n  data: Data,\n  options: CompareValuesOptions<K>,\n) {\n  const { key, type, value } = options;\n\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n  const primary = type === 'added' ? left : right;\n  const secondary = type === 'added' ? right : left;\n\n  if (!is.nullOrUndefined(value)) {\n    if (is.defined(primary)) {\n      // check if nested data matches\n      if (is.array(primary) || is.plainObject(primary)) {\n        return checkEquality(primary, secondary, value);\n      }\n    } else {\n      return equal(secondary, value);\n    }\n\n    return false;\n  }\n\n  if ([left, right].every(is.array)) {\n    return !secondary.every(isEqualPredicate(primary));\n  }\n\n  if ([left, right].every(is.plainObject)) {\n    return hasExtraKeys(Object.keys(primary), Object.keys(secondary));\n  }\n\n  return (\n    ![left, right].every(d => is.primitive(d) && is.defined(d)) &&\n    (type === 'added'\n      ? !is.defined(left) && is.defined(right)\n      : is.defined(left) && !is.defined(right))\n  );\n}\n\nexport function getIterables<K = Key>(previousData: Data, data: Data, { key }: Options<K> = {}) {\n  let left = nested(previousData, key);\n  let right = nested(data, key);\n\n  if (!isSameType(left, right)) {\n    throw new TypeError('Inputs have different types');\n  }\n\n  if (!canHaveLength(left, right)) {\n    throw new TypeError(\"Inputs don't have length\");\n  }\n\n  if ([left, right].every(is.plainObject)) {\n    left = Object.keys(left);\n    right = Object.keys(right);\n  }\n\n  return [left, right];\n}\n\nexport function hasEntry(input: Value) {\n  return ([key, value]: [string, Value]) => {\n    if (is.array(input)) {\n      return (\n        equal(input, value) ||\n        input.some(d => equal(d, value) || (is.array(value) && isEqualPredicate(value)(d)))\n      );\n    }\n\n    /* istanbul ignore else */\n    if (is.plainObject(input) && input[key]) {\n      return !!input[key] && equal(input[key], value);\n    }\n\n    return equal(input, value);\n  };\n}\n\nexport function hasExtraKeys(left: string[], right: string[]): boolean {\n  return right.some(d => !left.includes(d));\n}\n\nexport function hasValue(input: Value) {\n  return (value: Value) => {\n    if (is.array(input)) {\n      return input.some(d => equal(d, value) || (is.array(value) && isEqualPredicate(value)(d)));\n    }\n\n    return equal(input, value);\n  };\n}\n\nexport function includesOrEqualsTo<T>(previousValue: T | T[], value: T): boolean {\n  return is.array(previousValue)\n    ? previousValue.some(d => equal(d, value))\n    : equal(previousValue, value);\n}\n\nexport function isEqualPredicate(data: unknown[]) {\n  return (value: unknown) => data.some(d => equal(d, value));\n}\n\nexport function isSameType(...arguments_: ValidTypes[]): boolean {\n  return (\n    arguments_.every(is.array) ||\n    arguments_.every(is.number) ||\n    arguments_.every(is.plainObject) ||\n    arguments_.every(is.string)\n  );\n}\n\nexport function nested<T extends Data, K = Key>(data: T, property?: K) {\n  /* istanbul ignore else */\n  if (is.plainObject(data) || is.array(data)) {\n    /* istanbul ignore else */\n    if (is.string(property)) {\n      const props: Array<any> = property.split('.');\n\n      return props.reduce((acc, d) => acc && acc[d], data);\n    }\n\n    /* istanbul ignore else */\n    if (is.number(property)) {\n      return data[property];\n    }\n\n    return data;\n  }\n\n  return data;\n}\n"],"mappings":";AAAA,OAAOA,MAAA,MAAW;AAClB,OAAOC,GAAA,MAAQ;;;ACDf,OAAOC,KAAA,MAAW;AAClB,OAAOC,EAAA,MAAQ;AAIR,SAASC,cAAA,GAAiBC,UAAA,EAA0B;EACzD,OAAOA,UAAA,CAAWC,KAAA,CAAOC,CAAA,IAAeJ,EAAA,CAAGK,MAAA,CAAOD,CAAC,KAAKJ,EAAA,CAAGM,KAAA,CAAMF,CAAC,KAAKJ,EAAA,CAAGO,WAAA,CAAYH,CAAC,CAAC;AAC1F;AAEO,SAASI,cAAcC,IAAA,EAAYC,KAAA,EAAaC,KAAA,EAAc;EACnE,IAAI,CAACC,UAAA,CAAWH,IAAA,EAAMC,KAAK,GAAG;IAC5B,OAAO;EACT;EAEA,IAAI,CAACD,IAAA,EAAMC,KAAK,EAAEP,KAAA,CAAMH,EAAA,CAAGM,KAAK,GAAG;IACjC,OAAO,CAACG,IAAA,CAAKI,IAAA,CAAKC,QAAA,CAASH,KAAK,CAAC,KAAKD,KAAA,CAAMG,IAAA,CAAKC,QAAA,CAASH,KAAK,CAAC;EAClE;EAGA,IAAI,CAACF,IAAA,EAAMC,KAAK,EAAEP,KAAA,CAAMH,EAAA,CAAGO,WAAW,GAAG;IACvC,OACE,CAACQ,MAAA,CAAOC,OAAA,CAAQP,IAAI,EAAEI,IAAA,CAAKI,QAAA,CAASN,KAAK,CAAC,KAAKI,MAAA,CAAOC,OAAA,CAAQN,KAAK,EAAEG,IAAA,CAAKI,QAAA,CAASN,KAAK,CAAC;EAE7F;EAEA,OAAOD,KAAA,KAAUC,KAAA;AACnB;AAEO,SAASO,eACdC,YAAA,EACAC,IAAA,EACAC,OAAA,EACS;EACT,MAAM;IAAEC,MAAA;IAAQC,GAAA;IAAKC,QAAA;IAAUC;EAAK,IAAIJ,OAAA;EACxC,MAAMZ,IAAA,GAAOiB,MAAA,CAAOP,YAAA,EAAcI,GAAG;EACrC,MAAMb,KAAA,GAAQgB,MAAA,CAAON,IAAA,EAAMG,GAAG;EAE9B,IAAII,OAAA,GACF,CAAClB,IAAA,EAAMC,KAAK,EAAEP,KAAA,CAAMH,EAAA,CAAG4B,MAAM,MAAMH,IAAA,KAAS,cAAchB,IAAA,GAAOC,KAAA,GAAQD,IAAA,GAAOC,KAAA;EAElF,IAAI,CAACV,EAAA,CAAG6B,SAAA,CAAUP,MAAM,GAAG;IACzBK,OAAA,GAAUA,OAAA,IAAWjB,KAAA,KAAUY,MAAA;EACjC;EAEA,IAAI,CAACtB,EAAA,CAAG6B,SAAA,CAAUL,QAAQ,GAAG;IAC3BG,OAAA,GAAUA,OAAA,IAAWlB,IAAA,KAASe,QAAA;EAChC;EAEA,OAAOG,OAAA;AACT;AAEO,SAASG,cACdX,YAAA,EACAC,IAAA,EACAC,OAAA,EACA;EACA,MAAM;IAAEE,GAAA;IAAKE,IAAA;IAAMd;EAAM,IAAIU,OAAA;EAE7B,MAAMZ,IAAA,GAAOiB,MAAA,CAAOP,YAAA,EAAcI,GAAG;EACrC,MAAMb,KAAA,GAAQgB,MAAA,CAAON,IAAA,EAAMG,GAAG;EAC9B,MAAMQ,OAAA,GAAUN,IAAA,KAAS,UAAUhB,IAAA,GAAOC,KAAA;EAC1C,MAAMsB,SAAA,GAAYP,IAAA,KAAS,UAAUf,KAAA,GAAQD,IAAA;EAE7C,IAAI,CAACT,EAAA,CAAGiC,eAAA,CAAgBtB,KAAK,GAAG;IAC9B,IAAIX,EAAA,CAAGkC,OAAA,CAAQH,OAAO,GAAG;MAEvB,IAAI/B,EAAA,CAAGM,KAAA,CAAMyB,OAAO,KAAK/B,EAAA,CAAGO,WAAA,CAAYwB,OAAO,GAAG;QAChD,OAAOvB,aAAA,CAAcuB,OAAA,EAASC,SAAA,EAAWrB,KAAK;MAChD;IACF,OAAO;MACL,OAAOZ,KAAA,CAAMiC,SAAA,EAAWrB,KAAK;IAC/B;IAEA,OAAO;EACT;EAEA,IAAI,CAACF,IAAA,EAAMC,KAAK,EAAEP,KAAA,CAAMH,EAAA,CAAGM,KAAK,GAAG;IACjC,OAAO,CAAC0B,SAAA,CAAU7B,KAAA,CAAMgC,gBAAA,CAAiBJ,OAAO,CAAC;EACnD;EAEA,IAAI,CAACtB,IAAA,EAAMC,KAAK,EAAEP,KAAA,CAAMH,EAAA,CAAGO,WAAW,GAAG;IACvC,OAAO6B,YAAA,CAAarB,MAAA,CAAOsB,IAAA,CAAKN,OAAO,GAAGhB,MAAA,CAAOsB,IAAA,CAAKL,SAAS,CAAC;EAClE;EAEA,OACE,CAAC,CAACvB,IAAA,EAAMC,KAAK,EAAEP,KAAA,CAAMC,CAAA,IAAKJ,EAAA,CAAGsC,SAAA,CAAUlC,CAAC,KAAKJ,EAAA,CAAGkC,OAAA,CAAQ9B,CAAC,CAAC,MACzDqB,IAAA,KAAS,UACN,CAACzB,EAAA,CAAGkC,OAAA,CAAQzB,IAAI,KAAKT,EAAA,CAAGkC,OAAA,CAAQxB,KAAK,IACrCV,EAAA,CAAGkC,OAAA,CAAQzB,IAAI,KAAK,CAACT,EAAA,CAAGkC,OAAA,CAAQxB,KAAK;AAE7C;AAEO,SAAS6B,aAAsBpB,YAAA,EAAoBC,IAAA,EAAY;EAAEG;AAAI,IAAgB,CAAC,GAAG;EAC9F,IAAId,IAAA,GAAOiB,MAAA,CAAOP,YAAA,EAAcI,GAAG;EACnC,IAAIb,KAAA,GAAQgB,MAAA,CAAON,IAAA,EAAMG,GAAG;EAE5B,IAAI,CAACX,UAAA,CAAWH,IAAA,EAAMC,KAAK,GAAG;IAC5B,MAAM,IAAI8B,SAAA,CAAU,6BAA6B;EACnD;EAEA,IAAI,CAACvC,aAAA,CAAcQ,IAAA,EAAMC,KAAK,GAAG;IAC/B,MAAM,IAAI8B,SAAA,CAAU,0BAA0B;EAChD;EAEA,IAAI,CAAC/B,IAAA,EAAMC,KAAK,EAAEP,KAAA,CAAMH,EAAA,CAAGO,WAAW,GAAG;IACvCE,IAAA,GAAOM,MAAA,CAAOsB,IAAA,CAAK5B,IAAI;IACvBC,KAAA,GAAQK,MAAA,CAAOsB,IAAA,CAAK3B,KAAK;EAC3B;EAEA,OAAO,CAACD,IAAA,EAAMC,KAAK;AACrB;AAEO,SAASO,SAASwB,KAAA,EAAc;EACrC,OAAO,CAAC,CAAClB,GAAA,EAAKZ,KAAK,MAAuB;IACxC,IAAIX,EAAA,CAAGM,KAAA,CAAMmC,KAAK,GAAG;MACnB,OACE1C,KAAA,CAAM0C,KAAA,EAAO9B,KAAK,KAClB8B,KAAA,CAAM5B,IAAA,CAAKT,CAAA,IAAKL,KAAA,CAAMK,CAAA,EAAGO,KAAK,KAAMX,EAAA,CAAGM,KAAA,CAAMK,KAAK,KAAKwB,gBAAA,CAAiBxB,KAAK,EAAEP,CAAC,CAAE;IAEtF;IAGA,IAAIJ,EAAA,CAAGO,WAAA,CAAYkC,KAAK,KAAKA,KAAA,CAAMlB,GAAG,GAAG;MACvC,OAAO,CAAC,CAACkB,KAAA,CAAMlB,GAAG,KAAKxB,KAAA,CAAM0C,KAAA,CAAMlB,GAAG,GAAGZ,KAAK;IAChD;IAEA,OAAOZ,KAAA,CAAM0C,KAAA,EAAO9B,KAAK;EAC3B;AACF;AAEO,SAASyB,aAAa3B,IAAA,EAAgBC,KAAA,EAA0B;EACrE,OAAOA,KAAA,CAAMG,IAAA,CAAKT,CAAA,IAAK,CAACK,IAAA,CAAKiC,QAAA,CAAStC,CAAC,CAAC;AAC1C;AAEO,SAASU,SAAS2B,KAAA,EAAc;EACrC,OAAQ9B,KAAA,IAAiB;IACvB,IAAIX,EAAA,CAAGM,KAAA,CAAMmC,KAAK,GAAG;MACnB,OAAOA,KAAA,CAAM5B,IAAA,CAAKT,CAAA,IAAKL,KAAA,CAAMK,CAAA,EAAGO,KAAK,KAAMX,EAAA,CAAGM,KAAA,CAAMK,KAAK,KAAKwB,gBAAA,CAAiBxB,KAAK,EAAEP,CAAC,CAAE;IAC3F;IAEA,OAAOL,KAAA,CAAM0C,KAAA,EAAO9B,KAAK;EAC3B;AACF;AAEO,SAASgC,mBAAsBC,aAAA,EAAwBjC,KAAA,EAAmB;EAC/E,OAAOX,EAAA,CAAGM,KAAA,CAAMsC,aAAa,IACzBA,aAAA,CAAc/B,IAAA,CAAKT,CAAA,IAAKL,KAAA,CAAMK,CAAA,EAAGO,KAAK,CAAC,IACvCZ,KAAA,CAAM6C,aAAA,EAAejC,KAAK;AAChC;AAEO,SAASwB,iBAAiBf,IAAA,EAAiB;EAChD,OAAQT,KAAA,IAAmBS,IAAA,CAAKP,IAAA,CAAKT,CAAA,IAAKL,KAAA,CAAMK,CAAA,EAAGO,KAAK,CAAC;AAC3D;AAEO,SAASC,WAAA,GAAcV,UAAA,EAAmC;EAC/D,OACEA,UAAA,CAAWC,KAAA,CAAMH,EAAA,CAAGM,KAAK,KACzBJ,UAAA,CAAWC,KAAA,CAAMH,EAAA,CAAG4B,MAAM,KAC1B1B,UAAA,CAAWC,KAAA,CAAMH,EAAA,CAAGO,WAAW,KAC/BL,UAAA,CAAWC,KAAA,CAAMH,EAAA,CAAGK,MAAM;AAE9B;AAEO,SAASqB,OAAgCN,IAAA,EAASyB,QAAA,EAAc;EAErE,IAAI7C,EAAA,CAAGO,WAAA,CAAYa,IAAI,KAAKpB,EAAA,CAAGM,KAAA,CAAMc,IAAI,GAAG;IAE1C,IAAIpB,EAAA,CAAGK,MAAA,CAAOwC,QAAQ,GAAG;MACvB,MAAMC,KAAA,GAAoBD,QAAA,CAASE,KAAA,CAAM,GAAG;MAE5C,OAAOD,KAAA,CAAME,MAAA,CAAO,CAACC,GAAA,EAAK7C,CAAA,KAAM6C,GAAA,IAAOA,GAAA,CAAI7C,CAAC,GAAGgB,IAAI;IACrD;IAGA,IAAIpB,EAAA,CAAG4B,MAAA,CAAOiB,QAAQ,GAAG;MACvB,OAAOzB,IAAA,CAAKyB,QAAQ;IACtB;IAEA,OAAOzB,IAAA;EACT;EAEA,OAAOA,IAAA;AACT;;;ADhLe,SAAR8B,YACL/B,YAAA,EACAC,IAAA,EACgB;EAChB,IAAI,CAACD,YAAA,EAAcC,IAAI,EAAEP,IAAA,CAAKf,GAAA,CAAGmC,eAAe,GAAG;IACjD,MAAM,IAAIkB,KAAA,CAAM,6BAA6B;EAC/C;EAEA,IAAI,CAAC,CAAChC,YAAA,EAAcC,IAAI,EAAEjB,KAAA,CAAMC,CAAA,IAAKN,GAAA,CAAGS,WAAA,CAAYH,CAAC,KAAKN,GAAA,CAAGQ,KAAA,CAAMF,CAAC,CAAC,GAAG;IACtE,MAAM,IAAI+C,KAAA,CAAM,iCAAiC;EACnD;EAEA,MAAMC,KAAA,GAAQA,CAAC7B,GAAA,EAASZ,KAAA,KAA2B;IACjD,IAAI;MACF,OAAOmB,aAAA,CAAiBX,YAAA,EAAcC,IAAA,EAAM;QAAEG,GAAA;QAAKE,IAAA,EAAM;QAASd;MAAM,CAAC;IAC3E,QAAQ;MAEN,OAAO;IACT;EACF;EAEA,MAAMgB,OAAA,GAAUA,CAACJ,GAAA,EAAkBD,MAAA,EAAgBE,QAAA,KAA8B;IAC/E,IAAI;MACF,MAAMf,IAAA,GAAOiB,MAAA,CAAOP,YAAA,EAAcI,GAAG;MACrC,MAAMb,KAAA,GAAQgB,MAAA,CAAON,IAAA,EAAMG,GAAG;MAC9B,MAAM8B,SAAA,GAAYvD,GAAA,CAAGoC,OAAA,CAAQZ,MAAM;MACnC,MAAMgC,WAAA,GAAcxD,GAAA,CAAGoC,OAAA,CAAQV,QAAQ;MAEvC,IAAI6B,SAAA,IAAaC,WAAA,EAAa;QAC5B,MAAMC,cAAA,GAAiBD,WAAA,GACnBX,kBAAA,CAAmBnB,QAAA,EAAUf,IAAI,IACjC,CAACkC,kBAAA,CAAmBrB,MAAA,EAAQb,IAAI;QACpC,MAAM+C,eAAA,GAAkBb,kBAAA,CAAmBrB,MAAA,EAAQZ,KAAK;QAExD,OAAO6C,cAAA,IAAkBC,eAAA;MAC3B;MAEA,IAAI,CAAC/C,IAAA,EAAMC,KAAK,EAAEP,KAAA,CAAML,GAAA,CAAGQ,KAAK,KAAK,CAACG,IAAA,EAAMC,KAAK,EAAEP,KAAA,CAAML,GAAA,CAAGS,WAAW,GAAG;QACxE,OAAO,CAACV,MAAA,CAAMY,IAAA,EAAMC,KAAK;MAC3B;MAEA,OAAOD,IAAA,KAASC,KAAA;IAClB,QAAQ;MAEN,OAAO;IACT;EACF;EAEA,MAAM+C,WAAA,GAAcA,CAAClC,GAAA,EAAiBC,QAAA,EAAiBF,MAAA,KAA4B;IACjF,IAAI,CAACxB,GAAA,CAAGoC,OAAA,CAAQX,GAAG,GAAG;MACpB,OAAO;IACT;IAEA,IAAI;MACF,MAAMd,IAAA,GAAOiB,MAAA,CAAOP,YAAA,EAAcI,GAAG;MACrC,MAAMb,KAAA,GAAQgB,MAAA,CAAON,IAAA,EAAMG,GAAG;MAC9B,MAAM8B,SAAA,GAAYvD,GAAA,CAAGoC,OAAA,CAAQZ,MAAM;MAEnC,OACEqB,kBAAA,CAAmBnB,QAAA,EAAUf,IAAI,MAChC4C,SAAA,GAAYV,kBAAA,CAAmBrB,MAAA,EAAQZ,KAAK,IAAI,CAAC2C,SAAA;IAEtD,QAAQ;MAEN,OAAO;IACT;EACF;EAEA,MAAMK,SAAA,GAAYA,CAACnC,GAAA,EAAQD,MAAA,EAAgBE,QAAA,KAA8B;IACvE,IAAI,CAAC1B,GAAA,CAAGoC,OAAA,CAAQX,GAAG,GAAG;MACpB,OAAO;IACT;IAEA,IAAI;MACF,OAAOL,cAAA,CAAkBC,YAAA,EAAcC,IAAA,EAAM;QAAEG,GAAA;QAAKD,MAAA;QAAQE,QAAA;QAAUC,IAAA,EAAM;MAAY,CAAC;IAC3F,QAAQ;MAEN,OAAO;IACT;EACF;EAEA,MAAMkC,OAAA,GAAWpC,GAAA,IAAqB;IACpC,IAAI;MACF,MAAM,CAACd,IAAA,EAAMC,KAAK,IAAI6B,YAAA,CAAapB,YAAA,EAAcC,IAAA,EAAM;QAAEG;MAAI,CAAC;MAE9D,OAAO,CAAC,CAACd,IAAA,CAAKmD,MAAA,IAAU,CAAClD,KAAA,CAAMkD,MAAA;IACjC,QAAQ;MAEN,OAAO;IACT;EACF;EAEA,MAAMC,MAAA,GAAUtC,GAAA,IAAqB;IACnC,IAAI;MACF,MAAM,CAACd,IAAA,EAAMC,KAAK,IAAI6B,YAAA,CAAapB,YAAA,EAAcC,IAAA,EAAM;QAAEG;MAAI,CAAC;MAE9D,OAAO,CAACd,IAAA,CAAKmD,MAAA,IAAU,CAAC,CAAClD,KAAA,CAAMkD,MAAA;IACjC,QAAQ;MAEN,OAAO;IACT;EACF;EAEA,MAAME,SAAA,GAAYA,CAACvC,GAAA,EAAQD,MAAA,EAAgBE,QAAA,KAA8B;IACvE,IAAI,CAAC1B,GAAA,CAAGoC,OAAA,CAAQX,GAAG,GAAG;MACpB,OAAO;IACT;IAEA,IAAI;MACF,OAAOL,cAAA,CAAkBC,YAAA,EAAcC,IAAA,EAAM;QAAEG,GAAA;QAAKD,MAAA;QAAQE,QAAA;QAAUC,IAAA,EAAM;MAAY,CAAC;IAC3F,QAAQ;MAEN,OAAO;IACT;EACF;EAEA,MAAMsC,OAAA,GAAUA,CAACxC,GAAA,EAASZ,KAAA,KAA2B;IACnD,IAAI;MACF,OAAOmB,aAAA,CAAiBX,YAAA,EAAcC,IAAA,EAAM;QAAEG,GAAA;QAAKE,IAAA,EAAM;QAAWd;MAAM,CAAC;IAC7E,QAAQ;MAEN,OAAO;IACT;EACF;EAEA,OAAO;IAAEyC,KAAA;IAAOzB,OAAA;IAAS8B,WAAA;IAAaC,SAAA;IAAWC,OAAA;IAASE,MAAA;IAAQC,SAAA;IAAWC;EAAQ;AACvF"},"metadata":{},"sourceType":"module","externalDependencies":[]}